import 'package:flutter/material.dart';

class AdAlg {
  final String question;
  final String answer;
  AdAlg({@required this.question, @required this.answer});
}

String string="No Name";
List<AdAlg> names = [


  AdAlg(
      question: "Linear search Algorithm     ",
      answer: "    Linear search is used on a group of items. It relies on the technique of traversing a list from start to end by visiting properties of all the elements that are found on the way.  "
          "    \n   For example, suppose an array of with some integer elements. You should find and  print the position of all the elements with their value.  "
  "  \n Here , the linear search acts in a flow like matching each element from the beginning of the list to the end of the list with the integer, and if the condition is `True then printing the position of the element.  "
  "  \n \n   Implementing  Linear  Search  "
  "  \n   Below   steps  are required to implement the linear search.  "
  "  \n Step1  :  Traverse the array using for loop.  "
  "  \n Step2 :  In every iteration, compare the target value with the current value of the   array.   "
  "  \n  Step3 : If the values match, return the current index of the array. "
  "  \n  Step4: If the values do not match, shift on to the next array element. "
  "  \n Step5: If no match is found, return -1. "
  "  \n\n   Structure of   Linear Search  Algorithm  "
  "  \n  LinearSearch(array, key)  "
  "  \n   for each the item in array "
  "  \n   if item == value   "
  "  \n   return  its index  "
  "  \n\n Example of   Linear   Search Algorithm;   // Linear Search code in C++   given below   "
  "  \n   #include <iostream>  "
  "  \n  using namespace std; "
  "  \n int search(int array[], int n, int x)  {  "
  "  \n for (int i = 0; i < n; i++) "
  "  \n if (array[i] == x) "
  "  \n return I ;  "
  "  \n return -1 ;  "
  "  \n  }  "
  "  \n  int  main()  {  "
  "  \n  int array[] = {2, 4, 0, 1, 9} ;   "
  "  \n int x = 1;   "
  "  \n int n = sizeof(array) / sizeof(array[0]);   "
  "  \n  int result = search(array, n, x);   "
  "  \n   (result == -1) ?  cout << ' Element not found  ' :  cout << ' Element found at index :   '  << result;    ""   \n   }     "

  ),

  AdAlg(
      question: "Binary search Algorithm     " ,
      answer: "    Binary search works on sorted arrays. Binary search begins by comparing an element in the middle of the array with the target value. If the target value matches the element  ,  its position in the array is returned. "
          " \n If the target value is less than the element  ,  the search continues in the lower half of the array. "
          " \n If the target value is greater than the element, the search continues in the upper half of the array. "
          " \n By doing this, the algorithm eliminates the half in which the target value cannot lie in each iteration. ""  \n \n   Implementing binary  Search   "
          " \n Below  steps are required to implement the  binary  search. "
          " \n step1: The array in which searching is to be performed is :arr[]={3,4,5,6,7,8,9}; //  Initial array.   "
          " \n step2:Set two pointers low and high at the lowest and the highest positions respectively. step2: Set two pointers low and high at the lowest and the highest positions respectively.   "
          " \n step3:Find the middle element mid of the array ie.  arr[(low + high)/2] = 6   "
          " \n step4:If x == mid ,  then return mid. Else, compare the element to be searched with m.   "
          " \n step5: If x > mid, compare x with the middle element of the elements on the right side of mid. This is done by setting low to low = mid + 1.   "
          " \n step6: Else ,  compare x with the middle element of the elements on the left side of mid. This is done by setting high to high = mid - 1.    "
          " \n\n   Structure of   Binary  Search  Algorithm   "
          " \n    binarySearch(arr, x, low, high)   "
          " \n   if low > high  "
          " \n   return False  "
          " \n   else  "
          " \n   mid = (low + high) / 2   "
          " \n   if x == arr[mid] "
          " \n   return mid "
          " \n   else if x < arr[mid]  // x is on the right side  "
          " \n   return binarySearch(arr, x, mid + 1, high)  "
          " \n   else  // x is on the right side  "
          " \n   return binarySearch(arr, x, low, mid – 1)  "
          " \n\n Example of   Binary    Search Algorithm;    "
          " \n\n   #include<iostream>   "
          " \n   using namespace std;   "
          " \n   int binarySearch(int arr[], int p, int r, int num) {  "
          " \n  if (p <= r) {   "
          " \n  int mid = (p + r)/2;   "
          " \n  if (arr[mid] == num) "
          " \n  return mid ;   "
          " \n   if (arr[mid] > num)   "
          " \n return binarySearch(arr, p, mid-1, num) ;   "
          " \n  if (arr[mid] > num)  "
          " \n  return binarySearch(arr, mid+1, r, num) ;   "
          " \n   }   "
          " \n  return -1 ;   "
          " \n   }   "
          " \n   int main(void) {   "
          " \n  int arr[] = {1, 3, 7, 15, 18, 20, 25, 33, 36, 40} ;     "
          " \n   int n = sizeof(arr)/ sizeof(arr[0]) ;    "
          " \n   int num = 33 ;    "
          " \n   int index = binarySearch (arr, 0, n-1, num) ;     "
          " \n   if(index == -1)  "
          " \n   cout<< num <<' is not present in the array  ' ;   "

          " \n   else   "

          " \n   cout<< num <<' is present at index '<< index <<' in the array ' ;   "

          " \n  return 0 ;   "

          " \n   }    "

  ),

  AdAlg(
      question: "Bubble Sort Algorithm    ",
      answer: "   Bubble Sort is a comparison based sorting algorithm. In this algorithm adjacent elements are compared and swapped to make the correct sequence. "
          " \n This algorithm is simpler than other algorithms , but it has some drawbacks also. This algorithm is not suitable for a large number of data set. "
          " \n  It takes much time to solve the sorting tasks. "
          " \n\n How Bubble Sort Works "
          " \n  •  Starting from the first index, compare the first and the second elements. If the first element is greater than the second element, they are swapped.  "
          " \n  Now, compare the second and the third elements. Swap them if they are not in order.  "
          " \n  The above process goes on until the last element. "
          " \n  •  The same process goes on for the remaining iterations. After each iteration, the largest element among the unsorted elements is placed at the end.  "
          " \n  In each iteration, the comparison takes place up to the last unsorted element. "
          " \n  The array is sorted when all the unsorted elements are placed at their correct positions.  "
          " \n\n Structure of   Bubble Sort   Algorithm  "
          " \n  bubbleSort(array)  "
          " \n  for i <- 1 to indexOfLastUnsortedElement-1  "
          " \n  if leftElement > rightElement   "
          " \n  swap leftElement and rightElement   "
          " \n  end  bubbleSort  "
          " \n\n Example of   Bubble sort  Algorithm;    "
          " \n\n #include<iostream>  "
          " \n using namespace std ;   "
          " \n int main ()   "

          "  \n  {   "
          "  \n  int i, j,temp,pass=0;   "
          "   \n int a[10] = {10,2,0,14,43,25,18,1,5,45};   "
          "   \n cout <<'Input list ...\n';   "
          "   \n for(i = 0; i<10; i++) {  "
          "   \n cout <<a[i]<<'\t';  "
          "   \n }   "
          "   \n cout<<endl;  "
          "   \n for(i = 0; i<10; i++) {  "
          "   \n for(j = i+1; j<10; j++)  "
          "   \n { "
          "   \n if(a[j] < a[i]) {   "
          "   \n temp = a[i];  "
          "   \n a[i] = a[j];  "
          "   \n a[j] = temp;  "
          "   \n  }   "
          "   \n  }  "
          "   \n pass++;  "
          "   \n  }  "
          "   \n cout <<'Sorted Element List ...\n';  "
          "   \n for(i = 0; i<10; i++) { "
          "   \n cout <<a[i]<<'\t';  "
          "   \n  }  "
          "   \n cout<<'\n Number of passes taken to sort the list:'<<pass<<endl; "
          "   \n return 0;   "
          "   \n  }   "
          "   \n\nOutput: "
          "   \n  Input list :  "
          "   \n   10      2       0       14      43      25      18      1       5       45   "
          "   \n  Sorted Element output  List:"
          "   \n   0       1       2       5       10      14      18      25      43      45    "


  ),



  AdAlg (

      question: "Quick Sort Algorithm   ",
      answer: "   Quick Sort is one of the different Sorting Technique which is based on the concept of Divide and Conquer, just like merge sort. But in quick sort all the heavy lifting(major work) is done while dividing the array into subarrays, while in case of merge sort, all the real work happens during merging the subarrays. In case of quick sort  , the combine step does absolutely nothing.  "
          "  \n\n It  is also called partition-exchange sort. This algorithm divides the list into three main parts:  "
          "   \n •  Elements less than the Pivot element  "
          "  \n •  Pivot   element(Central element)  "
          "  \n•  Elements greater than the pivot element  "
          "  \n\n How Quick Sorting Works   "
          "  \n Following are the steps involved in quick sort algorithm:  "
          "  \n Step 1 − Choose the highest index value has pivot.  "
          "  \n Step 2 − Take two variables to point left and right of the list excluding pivot.  "
          "  \n Step 3 − left points to the low index.   "
          "  \n Step 4 − right points to the high.   "
          "  \n Step 5 − while value at left is less than pivot move right.  "
          "  \n Step 6 − while value at right is greater than pivot move left.  "
          "  \n Step 7 − if both step 5 and step 6 does not match swap left and right.  "
          "  \n Step 8 − if left ≥ right, the point where they met is new pivot.  "
          "  \n\n Structure of   Quick  Sort   Algorithm "
          "   \n procedure quickSort(left, right)   "
          "  \n if right-left <= 0  "
          "  \n return  "
          "  \n else  "
          "  \n pivot = A[right ]   "
          "  \n partition = partitionFunc(left, right, pivot)   "
          "  \n quickSort(left,partition-1)   "
          "  \n quickSort(partition+1,right)   "
          "  \n end if    "
          "  \n end procedure   "
          "  \n\n  Example of   quick  sort  Algorithm;      "


          "  \n\n #include <iostream> "
          "  \n using namespace std;  // Swap two elements - Utility function  "
          "  \n void swap(int* a, int* b)   "
          "  \n {  "
          "  \n  int t = *a;   "
          "  \n *a = *b;   "
          "  \n *b = t;  "
          "  \n  }  "
          "  \n int partition (int arr[], int low, int high)  "
          "  \n   {   "
          "  \n int pivot = arr[high];   "
          "  \n int i = (low - 1);  "
          "  \n for (int j = low; j <= high- 1; j++)  "
          "  \n  {  "
          "  \n if (arr[j] <= pivot)   // if current element is smaller than pivot, increment the low  element  swap elements at i and j   "
          "  \n  {    "
          "  \n i++;     //  increment index of smaller element  "
          "  \n swap(&arr[i], &arr[j]) ;   "
          "  \n  }  "
          "  \n  }  "
          "  \n swap(&arr[i + 1], &arr[high]);  "
          "  \n  return (i + 1); "
          "  \n   }  "
          "  \n void quickSort(int arr[], int low, int high)  //quicksort algorithm   "
          "  \n  {  "
          "  \n  if (low < high)   "
          "  \n   {   "
          "  \n  int pivot = partition(arr, low, high);   //partition the array "
          "  \n  quickSort(arr, low, pivot - 1);  //sort the sub arrays independently "
          "  \n quickSort(arr, pivot + 1, high);  "
          "  \n  }  "
          "  \n  }  "
          "  \n void displayArray(int arr[], int size) "
          "  \n {   "
          "  \n  int i;   "
          "  \n for (i=0; i < size; i++)  "
          "  \n cout<<arr[i]<<'\t';   "
          "  \n  }   "
          "  \n int main()   "
          "  \n  {  "
          "  \n  int arr[] = {12,23,3,43,51,35,19,45};  "
          "  \n int n = sizeof(arr)/sizeof(arr[0]);  "
          "  \n cout<<'Input array'<<endl;   "
          "  \n displayArray(arr,n);   "
          "  \n cout<<endl;  "
          "  \n quickSort(arr, 0, n-1);   "
          "  \n cout<<'Array sorted with quick sort'<<endl;  "
          "  \n displayArray(arr,n);  "
          "  \n return 0;  "
          "  \n  }  "
          "  \n\nOutput:   "
          "  \n Input array:   "
          "  \n   12      23      3       43      51      35      19      45    "
          "  \n Array sorted with quicksort:   "
          "  \n   3       12      19      23      35      43      45      51     "

  ),



  AdAlg(
      question: "Merge Sort Algorithm   " ,
      answer: "    Like  QuickSort , Merge Sort is a Divide and Conquer algorithm. It divides the input array into two halves, calls itself for the two halves , a nd then merges the two sorted halves.    "
          "   \n   The merge() function is used for merging two halves. The merge(arr, l, m, r) is a key process that assumes that arr[l..m] and arr[m+1..r] are sorted and merges the two sorted sub-arrays into one.   "
          "   \n\n How  Marge Sort works   "
          "   \n • Divide the unsorted list into n sublists, each containing one element (a list of one element is considered sorted).   "
          "   \n • Repeatedly merge sublists to produce new sorted sublists until there is only one sublist  remaining . This will be the sorted list.  "
          "   \n\n Structure of   Quick  Sort   Algorithm  "
          "   \n void merge_sort (int A[ ] , int start , int end )  "
          "   \n  {  "
          "   \n if( start < end ) {   "
          "   \n int mid = (start + end ) / 2 ;      // defines the current array in 2 parts.  "
          "   \n merge_sort (A, start , mid ) ;     // sort the 1st part of array.  "
          "   \n merge_sort (A,mid+1 , end ) ;     // sort the 2nd part of array.  "
          "   \n merge(A,start , mid , end ); // merge the both parts by comparing elements of both the parts.   "
          "   \n  }   "
          "   \n  }   "
          "   \n\n Example of   Marge   sort   Algorithm;   "
          "   \n\n #include <iostream>   "
          "   \n   using namespace std;   "
          "   \n  void merge(int *,int, int , int );    "
          "   \n void merge_sort(int *arr, int low, int high)   "
          "   \n  {   "
          "   \n int mid;   "
          "   \n if (low < high){   "
          "   \n mid=(low+high)/2;//divide the array at mid and sort independently using merge sort  "
          "   \n merge_sort(arr,low,mid);   "
          "   \n merge_sort(arr,mid+1,high);   "
          "   \n merge(arr,low,high,mid);   "
          "   \n  }   "
          "   \n  }   "

          "   \n void merge(int *arr, int low, int high, int mid)     "
          "   \n  {   "
          "   \n int i, j, k, c[50];  "
          "   \n i = low;  "
          "   \n k = low; "
          "   \n j = mid + 1; "
          "   \n while (i <= mid && j <= high) {  "
          "   \n if (arr[i] < arr[j]) {  "
          "   \n c[k] = arr[i];  "
          "   \n k++;  "
          "   \n i++;  "
          "   \n }  "
          "   \n else  {  "
          "   \n c[k] = arr[j];  "
          "   \n  k++;  "
          "   \n j++;  "
          "   \n }  "
          "   \n }  "
          "   \n  while (i <= mid) {  "
          "   \n  c[k] = arr[i];  "
          "   \n k++;  "
          "   \n i++;  "
          "   \n   }  "
          "   \n while (j <= high) {  "
          "   \n c[k] = arr[j];   "
          "   \n k++;   "
          "   \n j++;   "
          "   \n }   "
          "   \n for (i = low; i < k; i++)  {   "
          "   \n arr[i] = c[i];   "
          "   \n  }  "
          "   \n  }   "
          "   \n\n   nt  main()     "
          "   \n {   "
          "   \n  int myarray[30], num;  "
          "  \n cout<<' Enter number of elements to be sorted: ';  "
          "  \n cin>>num;  "
          "  \n cout<<'Enter  ' <<num<< '  elements to be sorted: ';   "
          "  \n for (int i = 0; i < num; i++) { cin>>myarray[i];   "
          "  \n  "
          "  \n merge_sort(myarray, 0, num-1);  "
          "  \n cout<<'Sorted array\n ';   "
          "  \n for (int i = 0; i < num; i++)  "
          "  \n  {  "
          "  \n  cout<<myarray[i]<<'\t';  "
          "  \n  }  "
          "  \n  }   "
          "    \n\n Output:    "

          "   \n Enter the number of elements to be sorted:10   "
          "   \n Enter 10 elements to be sorted: 101   10    2    43   12   54    34   64   89   76   "
          "   \n Sorted array  "
          "   \n 2       10      12      34      43      54      64      76      89      101    "

  ),

  AdAlg(
      question: "selection  Sort Algorithm    " ,
      answer: "    Selection sort is a simple sorting algorithm. This sorting algorithm is an in-place comparison-based algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted part at the right end. Initially, the sorted part is empty and the unsorted part is the entire list.  "
          "   \n The smallest element is selected from the unsorted array and swapped with the leftmost element, and that element becomes a part of the sorted array. This process continues moving unsorted array boundary by one element to the right.  "
          "   \n \n  How  Selection Sort Works    "
          "   \n  • Step 1 − Set MIN to location 0   "
          "    \n  • Step 2 − Search the minimum element in the list   "
          "   \n  • Step 3 − Swap with value at location MIN   "
          "   \n  • Step 4 − Increment MIN to point to next element   "
          "   \n  • Step 5 − Repeat until list is sorted   "
          "   \n\n Structure of   selection   Sort   Algorithm "
          "   \n selectionSort(array, size  )"
          "   \n repeat (size - 1) times  "
          "   \n set the first unsorted element as the minimum  "
          "   \n for each of the unsorted elements  "
          "   \n  if element < currentMinimum  "
          "   \n  set element as new minimum  "
          "   \n swap minimum with first unsorted position  "
          "   \n end   selectionSort   "
          "   \n\n   Example of  Selection   sort   Algorithm;     "
          "   \n\n  #include<iostream>   "
          "   \nusing namespace std;   "
          "   \n  int main()  "
          "   \n{  "
          "   \n int i,j,n,loc,temp,min,a[30];   "
          "   \n cout<<'Enter the number of elements:;'  "
          "   \n cin>>n;   "
          "   \n cout<<'\nEnter the elements\n' ;   "
          "   \n for(i=0;i<n;i++)   "
          "   \n   {  "
          "   \n cin>>a[i];   "
          "   \n  }   "
          "   \n for(i=0;i<n-1;i++)  "
          "   \n  {   "
          "   \n  min=a[i];   "
          "   \n loc=i;  "
          "   \n for(j=i+1;j<n;j++)  "
          "   \n   {  "
          "   \n  if(min>a[j])   "
          "   \n   {  "
          "   \n  min=a[j];   "
          "   \n loc=j;   "
          "   \n   }  "
          "   \n   }   "
          "   \n temp=a[i];   "
          "   \n a[i]=a[loc];  "
          "   \n a[loc]=temp;   "
          "   \n  }   "
          "   \n cout<<' \nSorted list is as follows\n ';  "
          "   \n for(i=0;i<n;i++)  "
          "   \n   {  "
          "   \n cout<<a[i];    "
          "   \n   }  "
          "   \n return 0 ;    "
          "   \n  }   "
          "   \n\n Output  "
          "   \n Enter the number of elements:8    "
          "   \n Enter the elements:    12  ,    11,    4,   5,   6,   22,   98,     9    "
          "   \n Sorted list is as follows:  4,   5,  6,    9,    11,   12,    22,     98   "


  ),

  AdAlg(
      question: "Heap Sort Algorithm   ",
      answer: "    Heap Sort is one of the best sorting methods being in-place and with no quadratic worst-case running time. Heap sort involves building a Heap data structure from the given array and then utilizing the Heap to sort the array.    "
          "   \n You must be wondering, how converting an array of numbers into a heap data structure will help in sorting the array. To understand this, let's start by understanding what is a Heap.   "
          "   \n\n • Shape Property: Heap data structure is always a Complete Binary Tree, which means all levels of the tree are fully filled.  "
          "   \n • Heap Property: All nodes are either greater than or equal to or less than or equal to each of its children. If the parent nodes are greater than their child nodes, heap is called a Max-Heap, and if the parent nodes are smaller than their child nodes, heap is called Min-Heap.   "
          "   \n\n   How Heap Sort Works   "
          "   \n Heap sort algorithm is divided into two basic parts:   "
          "   \n Creating a Heap of the unsorted list/array.   "
          "   \n Then a sorted array is created by repeatedly removing the largest/smallest element from the heap, and inserting it into the array. The heap is reconstructed after each removal.   "
          "   \n\n Below we have a simple C++ program implementing the Heap sort algorithm.  "
          "   \n \n #include <iostream>  "
          "    \n using namespace std;   "
          "   \n void heapify(int arr[], int n, int root) // function to heapify the tree  "
          "   \n  {   "
          "   \n int largest = root;   // root is the largest element  "
          "   \n int l = 2*root + 1;   //   left = 2*root + 1  "
          "   \n int r = 2*root + 2;   //    right = 2*root + 2  "
          "   \n if (l < n && arr[l] > arr[largest]) ;  // If left child is larger than root  "
          "   \n  largest = l;  "
          "   \n  if (r < n && arr[r] > arr[largest])   ;   // If right child is larger than largest so far  "
          "   \n largest = r ;   "
          "   \n   if (largest != root)// If largest is not root   "
          "   \n {   "
          "   \n swap(arr[root], arr[largest]);  //swap root and largest  "
          "   \n  heapify(arr, n, largest);  // Recursively heapify the sub-tree   "
          "   \n    }   "
          "   \n   }   "
          "   \n void heapSort(int arr[], int n)// implementing heap sort   "
          "   \n {    "
          "   \n for (int i = n / 2 - 1; i >= 0; i--)  // build heap   "
          "   \n heapify(arr, n, i);   "
          "   \n for (int i=n-1; i>=0; i--)// extracting elements from heap one by one  "
          "   \n {   "
          "   \n swap(arr[0], arr[i]); // Move current root to end  "
          "   \n  heapify(arr, i, 0); // again call max heapify on the reduced heap  "
          "   \n    }   "
          "   \n   }   "
          "   \n  void displayArray(int arr[], int n)    "
          "   \n  {    "
          "   \n for (int i=0; i<n; ++i)  "
          "   \n cout << arr[i] << ' ';   "
          "   \n cout << '\n';   "
          "   \n }   "
          "   \n int main() // main program "
          "   \n  {   "
          "   \n int heap_arr[] = {4,17,3,12,9,6};  "
          "   \n int n = sizeof(heap_arr)/sizeof(heap_arr[0]);   "
          "   \n cout<<' Input array  '<<endl;   "
          "   \n   displayArray(heap_arr,n);   "
          "   \n heapSort(heap_arr, n);   "
          "   \n cout << 'Sorted array'<<endl; "
          "   \n  displayArray(heap_arr, n);   "
          "   \n }   "
          "   \n\n Output:   "
          "   \n Input array   "
          "   \n 4 17 3 12 9 6   "
          "   \n Sorted array    "
          "   \n 3 4 6 9 12 17   "


  ),

  AdAlg(
      question: "Insertion Sort Algorithms  ",
      answer: "    An insertion sort compares values in turn, starting with the second value in the list. \n If this value is greater than the value to the left of it, no changes are made. Otherwise this value is repeatedly moved left until it meets a value that is less than it. "
  "\n   The sort process then starts again with the next value.   "
  "   \n This is an in-place comparison-based sorting algorithm. Here, a sub-list is maintained which is always sorted.   "
  "   \n\n How Insertion Sort Works   "
  "   \n so we can derive simple steps by which we can achieve insertion sort.  "
  "   \n Step 1 − If it is the first element, it is already sorted. return 1;   "
  "   \n Step 2 − Pick next element    "
  "   \n Step 3 − Compare with all elements in the sorted sub-list   "
  "   \n Step 4 − Shift all the elements in the sorted sub-list that is greater than the value to be sorted    "
  "   \n Step 5 − Insert the value     "
  "   \n Step 6 − Repeat until list is sorted  "
  "   \n\n Structure of   selection   Sort   Algorithm   "
  "   \n insertionSortR(array A, int n)   "
  "   \n  if n > 0  "
  "   \n insertionSortR(A, n-1)  "
  "   \n x ← A[n]   "
  "   \n j ← n-1  "
  "   \n while j >= 0 and A[j] > x    "
  "   \n  A[j+1] ← A[j]   "
  "   \n  j ← j-1   "
  "   \n  end while   "
  "   \n A[j+1] ← x    "
  "   \nend if   "
  "   \n end function   "
  "   \n\n Below we have a simple C++ program implementing the  insertion  sort algorithm. "
  "   \n #include<iostream>   "
  "   \n using namespace std;   "
  "   \n int main()  "
  "   \n {    "
  "   \n int i,j,n,temp,a[30];  "
  "   \n cout<<'Enter the number of elements: ' ;   "
  "   \n cin>>n;   "
  "   \n cout<<' \nEnter the elements\n ';    "
  "   \n for(i=0;i<n;i++)    "
  "   \n {    "
  "   \n  cin>>a[i];   "
  "   \n   }  "
  "   \n for(i=1;i<=n-1;i++)   "
  "   \n {    "
  "   \n temp=a[i];   "
  "   \n j=i-1;    "
  "   \n while((temp<a[j])&&(j>=0))    "
  "   \n {   "
  "   \n  a[j+1]=a[j];    //moves element forward    "
  "   \n  j=j-1;     "
  "   \n    }    "
  "   \n a[j+1]=temp;    //insert element in proper place   "
  "   \n   }   "
  "   \n  cout<<' /nSorted list is as follows '; "
  "   \n for(i=0;i<n;i++)   "
  "   \n {  "
  "   \n cout<<a[i]<<  ' '  ;      "
  "   \n  }"
  "   \n  return 0;  "
  "   \n  }  "
  "   \n\n Output:   "
  "   \n Enter the elements  :   12   4   17  3  6  19        "
      "\n Sorted list as  follows  :  3   4   6   12   17   19     "

  ),



];




